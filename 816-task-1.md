你是一位精通信息检索和数据科学的 Python 专家，来重构我项目中的一个核心函数。

#### 1. 项目背景与现状 (Context)

我的项目是一个面向化学科学文献的智能问答系统。其中一个关键步骤是，根据一个初步生成的、可能不精确的“假设实体”，从一个包含约 13,000 个标准化学实体（格式基本为 `snake_case`）的“可用列表”中，检索出一个小而相关的候选列表，作为上下文提供给下游的大语言模型 (LLM) Agent 进行精确的工具调用。我的系统分别用GPT-4.1和GPT-4.1-nano驱动，4.1能很好的完成任务，但是会花费大量token，4.1-nano则会挑选出不够好的实体导致结果不准确或不佳。

**当前的代码实现**非常初级：

1.  它使用 `re.split(r'[_\-\s]+', entity_name)` 对查询实体和可用列表中的每个实体进行分词。
2.  然后，它会召回所有**包含了查询实体中任意一个单词**的实体。
3.  这本质上是一种布尔“OR”检索。

**当前实现遇到的严重问题：** 这个方法召回的实体列表太大（通常超过100个），且因为化学名称的组合性（大量实体共享如 `sodium`, `assay`, `displacement` 等词根），导致召回的列表充满了大量高度相似但错误的“噪音”。这给下游的 LLM Agent 带来了巨大的困扰，其表现与直接处理上万个实体相比几乎没有改善。

#### 2. 核心需求 (Objective)

你的任务是废弃当前的布尔检索逻辑，并用一个先进的、基于**排序的检索 (Ranked Retrieval)** 系统来替代它。

这个新的检索系统必须满足以下要求：

-   **本地化与程序化：** 整个过程应在本地运行，不依赖外部 API 或数据库。
-   **高性能：** 检索速度必须快。
-   **高相关性：** 返回的应该是一个根据相关性得分从高到低排序的列表。
-   **结果可控：** 最终返回一个固定数量 (Top-K) 的结果，而不是一个数量不定的集合。

#### 3. 详细的技术实现方案 (The Plan)

我们将采用一种专业的**混合评分模型**，结合 **BM25 算法**和**Jaccard 相似度**的优点。

**请实现一个 `RankedRetriever` 类，包含以下逻辑：**

**A. 初始化 (`__init__`):**

-   该类在初始化时接收完整的“可用实体列表”（`available_entities: List[str]`）。
-   在初始化过程中，完成所有必要的预处理和索引工作：
    1.  **为 BM25 创建索引：**
        -   使用 `re.split(r'[_\-\s]+', entity)` 对列表中的每一个实体进行**词级分词**，创建一个词的语料库 (tokenized corpus)。
        -   使用 `rank-bm25-plus` 或类似库，对这个词语料库进行索引。
    2.  **为 Jaccard 创建索引：**
        -   对列表中的每一个实体，将其转换为**字符级的 trigrams (n=3) 集合**，并存储起来。

**B. 检索方法 (`search`):**

-   该方法接收一个查询字符串 (`query: str`) 和一个可选的 `k: int` (默认为 15)。
-   **运行时逻辑如下：**
    1.  **处理查询：**
        -   对查询字符串进行相同的词级分词，用于 BM25。
        -   对查询字符串进行相同的字符级 trigrams (n=3) 转换，用于 Jaccard。
    2.  **计算分数：**
        -   **BM25 分数：** 使用已索引的 BM25 模型，获取语料库中每个实体相对于查询的 BM25 分数。
        -   **Jaccard 分数：** 遍历预处理好的 N-grams 索引，计算查询与每个实体的 N-grams 集合之间的 Jaccard 相似度。
    3.  **分数归一化 (Normalization)：** 由于 BM25 的分数范围不固定，而 Jaccard 在 [0, 1] 区间，你需要将两组分数各自归一化到 [0, 1] 区间，以便公平组合。（例如，使用 `min-max scaling`：`(score - min_score) / (max_score - min_score)`）。
    4.  **计算混合分数：**
        -   对每个实体，使用以下公式计算最终得分： `Final Score = (0.5 * normalized_bm25_score) + (0.5 * normalized_jaccard_score)`
    5.  **返回 Top-K 结果：**
        -   根据 `Final Score` 对所有实体进行降序排序。
        -   返回得分最高的 Top-K 个实体的列表。

**C. 推荐库：**

-   BM25: `rank-bm25-plus`
-   Jaccard: Python 原生的 `set` 操作即可。

**D. 其他需求：**

-  使用的超参数应该在settings.yaml文件中进行配置。

------

**总结：** 我需要你提供一个封装了上述逻辑的、docstring良好、可直接使用的 Python `RankedRetriever` 类。这个类将取代我现有的低效检索代码（应该是位于entity matcher.py文件中） ，为我的 AI Agent 提供一个干净、小巧且高度相关的上下文列表。