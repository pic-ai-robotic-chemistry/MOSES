**你的角色：** 你是一位顶级的Python软件架构师，精通LangGraph和多智能体系统的设计与实现。你的任务是对我现有的查询系统进行一次深刻的架构重构，目标是将其从一个相对无状态的流程，转变为一个有记忆、懂诊断、会根据本体的**结构化信息**进行智能策略调整的、高度鲁棒的迭代系统。

**当前架构与核心挑战：** 系统当前流程为 `hypothesis -> query parser -> refine_entities -> strategy -> palnner -> execute -> validate`。`refine_entities` 节点能高召回率地检索到候选类并存入`QueryState.refined_classes`。 **核心瓶颈在于：**

1.  **LLM筛选不力**：后续的LLM智能体在从`refined_classes`这个高质量池中做最终选择时，表现不稳定，常常会错误地丢弃正确选项或选择信息贫乏的选项。
2.  **迭代失忆**：系统缺乏对每次具体操作（“哪个工具+哪些参数”）的记忆，导致迭代无法吸取教训，可能会重复错误，或错误地修改已成功的操作。

**重构蓝图与核心指令：**

**第一部分：建立以“工具调用”为核心的迭代记忆与新工具**

1.  **新增核心工具 - `get_class_richness_info`(允许改为更适合的名称，作为LLM 的工具函数，其docstring、名称、参数需要清晰明确)**:
    -   在`OntologyTools`中，必须创建一个新的、快速的工具函数。
    -   **功能**: 接收一个类名，返回该类的“信息丰富度”指标。这必须包括（且主要包括）但不限于：**关联的Property数量**和**Sourced Information数量**（例如实例、公理等的数量）。
    -   **目的**: 以低成本、程序化的方式，在执行昂贵的数据查询前，预判一个类的潜在价值。
    -   **说明**： 工具函数直接操作owl本体，利用owlready2的API。
2.  **复用`refined_classes`字段**：明确一点，`QueryState.refined_classes` **就是**我们唯一的高召回候选集来源。**不要**创建任何新的、冗余的字段。
3.  **精确记录尝试历史**: 在`QueryState`中，创建一个核心字段`tried_tool_calls: Dict[str, Dict]`来记录尝试历史。
4.  **实现“工具调用签名”**: 创建一个工具函数，生成由**工具函数名**和**标准化的参数**共同决定的稳定、唯一的“调用签名”，作为记忆系统中的Key。

**第二部分：智能体职责重定义与“提示”机制**

1.  **`Validator` -> 职责简化为“分类器”**:
    -   重构`ValidationAgent`。其新职责是对每一次工具调用的结果进行**分类**，打上预定义的标签，如 `sufficient`、`insufficient_properties`（缺乏性质信息）、`insufficient`（全面的缺乏信息）、`no_results` 等。它只做诊断，不做决策。
2.  **引入`Refiner` -> 成为“代码驱动的决策大脑”**:
    -   新建一个纯Python的`QueryRefiner`类。它的核心方法`propose_next_action`接收当前状态和验证报告。在每次迭代验证之后，`Refiner`会启动，负责：

        1.  读取`Validator`给出的分类标签。
        2.  查阅“迭代记忆”（哪些调用已尝试过）。
        3.  基于一套明确的规则，决定下一步的**整体战略**。

        **使其他智能体 -> 成为“可被引导的执行者”**：`Planner`、`Parser`等现有智能体将被改造，能够接收并理解来自`Refiner`的“提示”（`add_tool_hints`（增加工具函数，主要是get_class_properties和parse_class_definition，根据工具函数功能和validator的分类结果决策）, `expansion_hints`），从而在规划和解析时遵循更明确的策略指导。
    -   **赋予其执行新工具的能力**: `Refiner`必须能够调用`get_class_richness_info`工具。
    -   **核心决策逻辑**:
        -   当`Refiner`基于`Validator`的分类（如`no_results`）决定需要“扩展类（expand_classes）”时，它现在有了一个更强大的能力：**它可以调用新工具来评估`refined_classes`中所有候选项的丰富度，并对其进行重排序**。
        -   **请你（AI Coder）来决策最佳实现方式**: 你可以**直接修改`refined_classes`列表的顺序**，或者**在`QueryState`中新增一个用于排序的字段**。请在你的实施方案中陈述你的选择并说明理由。
    -   `Refiner`的最终输出是给特定智能体的“提示”（`add_tool_hints`, `expansion_hints`），用以指导下一轮的行动。

**第三部分：增强前端代理与工作流内置检查**

1.  **增强`HypotheticalDocumentAgent`进行“基于信息的假设”**:
    -   **赋予其新工具**: 此Agent必须被赋予调用以下三个工具的能力：`search_classes`（用于处理缩写，查找本体中所有包含该缩写的类名）、`get_class_info`（用于检查存在性和获取基本信息辅助确认缩写的全称）和我们新增的`get_class_richness_info`。
    -   **评估并选择实现方案**: 对于歧义缩写的预处理，你需要评估并选择一种最合适的方案：
        -   **方案A (增强Prompt)**: 修改现有Agent，使其遵循“检测缩写 -> 调用`search_classes` -> 评估候选类的存在性与丰富度 -> 生成假设”的逻辑链。
        -   **方案B (专用ReAct Agent)**: 使用LangGraph prebuilt的ReAct Agent来实现这个具有“思考->工具调用->观察”能力的子任务。
    -   **请在你的实施方案中明确你的选择并简述理由。**
2.  **在`normalize_query`节点中实现“智能化的LLM停滞检测”**:
    -   此项检查应在`QueryParserAgent`生成了标准化的查询**之后**，作为一个独立的、由代码实现的步骤。
    -   当检测到LLM选择的实体与上一轮高度相似时，执行以下**增强逻辑**: a.  调用`EntityMatcher`获取一小批新的、语义相似的候选项。 b.  **对这一小批候选项，逐一调用`get_class_richness_info`工具**。 c.  最终，**强制注入**那个**兼具高语义相似度和高信息丰富度**的、未被尝试过的最佳候选项。

**你的任务：分析现有代码，并落地以上重构计划**

请严格按照以下步骤进行：

1.  **代码审查**: 首先，请详细阅读`query_workflow.py`, `query_agents.py`, `entity_matcher.py` 和 `ontology_tools.py`，确保你完全理解现有逻辑（基本存在于queryteam文件夹中）。如有任何信息缺失，可以询问我。
2.  **提出具体实施方案**: 基于你的理解，请简要说明你将如何在现有代码结构中实现上述所有要点，特别是新工具的实现、`Refiner`中重排序的策略以及你为`HypotheticalDocumentAgent`选择的方案。
3.  **编码实现**: 在我们对方案达成共识后，请你开始编码。确保所有新增状态字段均为可选（`Optional`），以保持向后兼容性，并在关键逻辑点添加详细的日志。